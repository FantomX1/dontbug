// Copyright Â© 2016 Sidharth Kshatriya
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package engine

import (
	"bytes"
	"fmt"
	"github.com/fatih/color"
	"log"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"sort"
	"strings"
	"time"
	"unsafe"
)

var gBreakCskeletonHeader = `
/*
 * Copyright 2016 Sidharth Kshatriya
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file was autogenerated by dontbug on ` + time.Now().String() + `
 * IMPORTANT -- DO NOT remove/edit/move comments with ### or $$$ or &&&
 */
#include "php.h"
#include "php_dontbug.h"

void dontbug_break_location(zend_string* zfilename, zend_execute_data *execute_data, int lineno, unsigned long level) {
    zend_ulong hash = zfilename->h;
    char *filename = ZSTR_VAL(zfilename);
`

var gBreakCskeletonFooter = `
}
`

var gLevelLocationHeader = `
void dontbug_level_location(unsigned long level, char* filename, int lineno) {
    int count = 0;
`

var gLevelLocationFooter = `
}
`

type myUintArray []uint64
type myMap map[uint64][]string

func (arr myUintArray) Len() int {
	return len(arr)
}

func (arr myUintArray) Less(i, j int) bool {
	return arr[i] < arr[j]
}

func (arr myUintArray) Swap(i, j int) {
	arr[j], arr[i] = arr[i], arr[j]
}

func makeDontbugExtension(extDir string, phpPath string) {
	extDirAbsPath := getAbsPathOrFatal(extDir)

	// Save the working directory
	cwd, err := os.Getwd()
	fatalIf(err)

	phpizePath := path.Dir(phpPath) + "/phpize"
	Verbosef("Trying to find phpize (%v) corresponding to the php executable (%v)\n", phpizePath, phpPath)
	_, err = os.Stat(phpizePath)
	if err != nil {
		log.Fatal("Note able to find `phpize'. Error: ", err)
	}

	os.Chdir(extDirAbsPath)
	phpizeOut, err := exec.Command(phpizePath).CombinedOutput()
	if err != nil {
		fmt.Println(string(phpizeOut))
		log.Fatal(err)
	} else {
		Verboseln(string(phpizeOut))
		color.Green("dontbug: Successfully ran phpize in dontbug zend extension directory")
	}

	makeOutput, err := exec.Command("make").CombinedOutput()
	if err != nil {
		fmt.Println(string(makeOutput))
		log.Fatal(err)
	} else {
		Verboseln(string(makeOutput))
		color.Green("dontbug: Successfully compiled the dontbug zend extension")
	}

	// Restore the old working directory
	os.Chdir(cwd)
}

func doGeneration(rootDir, extDir string, maxStackDepth int, phpPath string) {
	generateBreakFile(rootDir, extDir, gBreakCskeletonHeader, gBreakCskeletonFooter, gLevelLocationHeader, gLevelLocationFooter, maxStackDepth)
	makeDontbugExtension(extDir, phpPath)
}

func generateBreakFile(rootDir, extDir, skelHeader, skelFooter, skelLocHeader, skelLocFooter string, maxStackDepth int) {
	rootDirAbsPath := getAbsPathOrFatal(rootDir)
	extDirAbsPath := getAbsPathOrFatal(extDir)

	// Open the dontbug_break.c file for generation
	breakFileName := extDirAbsPath + "/dontbug_break.c"
	f, err := os.Create(breakFileName)
	fatalIf(err)
	defer f.Close()

	Verboseln("dontbug: Generating", breakFileName, "for all PHP code in", rootDirAbsPath)
	// All is good, now go ahead and do some real work
	ar, m := makeMap(rootDirAbsPath)
	fmt.Fprintf(f, "%v%v\n", numFilesSentinel, len(ar))
	fmt.Fprintf(f, "%v%v\n", maxStackDepthSentinel, maxStackDepth)
	fmt.Fprintln(f, skelHeader)
	fmt.Fprintln(f, generateFileBreakBody(ar, m))
	fmt.Fprintln(f, skelFooter)
	fmt.Fprintln(f, skelLocHeader)
	fmt.Fprintln(f, generateLocBody(maxStackDepth))
	fmt.Fprintln(f, skelLocFooter)

	color.Green("dontbug: Code generation complete. Compiling dontbug.so zend extension (please wait a few seconds)")
}

func generateLocBody(maxStackDepth int) string {
	var buf bytes.Buffer

	for level := 0; level < maxStackDepth; level++ {
		buf.WriteString(fmt.Sprintf("    if (level <= %v) {\n", level))
		buf.WriteString(fmt.Sprintf("        count++; %v %v\n", levelSentinel, level))
		buf.WriteString(fmt.Sprint("    }\n"))
	}

	return buf.String()
}

func allFiles(directory string, c chan string) {
	filepath.Walk(directory, func(filepath string, info os.FileInfo, err error) error {
		fatalIf(err)

		// @TODO make this more generic. Get extensions from a yaml file??
		if !info.IsDir() && (path.Ext(filepath) == ".php" || path.Ext(filepath) == ".module") {
			c <- filepath
		}

		return nil
	})
	close(c)
}

// Repeat a space n times
func s(n int) string {
	return strings.Repeat(" ", n)
}

func ifThenElse(ifc, ifb, elseifc, elseifb, elseb string, indent int) string {
	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf("%vif (%v) {\n", s(indent), ifc))
	buf.WriteString(fmt.Sprintf("%v", ifb))
	buf.WriteString(fmt.Sprintf("%v} else if (%v) {\n", s(indent), elseifc))
	buf.WriteString(fmt.Sprintf("%v", elseifb))
	buf.WriteString(fmt.Sprintf("%v} else {\n", s(indent)))
	buf.WriteString(fmt.Sprintf("%v", elseb))
	buf.WriteString(fmt.Sprintf("%v}\n", s(indent)))
	return buf.String()
}

func ifThen(ifc, ifb, elseb string, indent int) string {
	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf("%vif (%v) {\n", s(indent), ifc))
	buf.WriteString(fmt.Sprintf("%v", ifb))
	buf.WriteString(fmt.Sprintf("%v} else {\n", s(indent)))
	buf.WriteString(fmt.Sprintf("%v", elseb))
	buf.WriteString(fmt.Sprintf("%v}\n", s(indent)))
	return buf.String()
}

func eq(rhs uint64) string {
	return fmt.Sprintf("hash == Z_UL(%v)", rhs)
}

func lt(rhs uint64) string {
	return fmt.Sprintf("hash < Z_UL(%v)", rhs)
}

// @TODO deal with hash collisions
func foundHash(hash uint64, matchingFiles []string, indent int) string {
	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf("%v// hash == %v\n", s(indent), hash))
	buf.WriteString(fmt.Sprintf("%vreturn; %v %v\n", s(indent), phpFilenameSentinel, matchingFiles[0]))
	return buf.String()
}

// "Daniel J. Bernstein, Times 33 with Addition" string hashing algorithm
// Its the string hashing algorithm used by PHP.
// See https://github.com/php/php-src/blob/PHP-7.0.9/Zend/zend_string.h#L291 for the C language implementation
//
// (64 bit version of function. For 32 bit version see below)
//
func djbx33a64(byteStr string) uint64 {
	var hash uint64 = 5381
	i := 0

	length := len(byteStr)
	for ; length >= 8; length = length - 8 {
		for j := 0; j < 8; j++ {
			hash = ((hash << 5) + hash) + uint64(byteStr[i])
			i++
		}
	}

	for j := length; j >= 1; j-- {
		hash = ((hash << 5) + hash) + uint64(byteStr[i])
		i++
	}

	return hash | (1 << 63)
}

// This is the 32 bit version of djbx33a
// See djbx33a64() above for more information about this function
func djbx33a32(byteStr string) uint32 {
	var hash uint32 = 5381
	i := 0

	length := len(byteStr)
	for ; length >= 8; length = length - 8 {
		for j := 0; j < 8; j++ {
			hash = ((hash << 5) + hash) + uint32(byteStr[i])
			i++
		}
	}

	for j := length; j >= 1; j-- {
		hash = ((hash << 5) + hash) + uint32(byteStr[i])
		i++
	}

	return hash | (1 << 31)
}

func makeMap(rootdir string) (myUintArray, myMap) {
	longIs64bits := false
	if unsafe.Sizeof(uint(0)) == 8 {
		longIs64bits = true
	}

	c := make(chan string, 100)
	go allFiles(rootdir, c)
	m := make(myMap)
	hashAr := make(myUintArray, 0, 100)
	var hash uint64
	for fileName := range c {
		if longIs64bits {
			hash = djbx33a64(fileName)
		} else {
			// This is OK cause we're just interested in how the numeric literals print out during code generation
			hash = uint64(djbx33a32(fileName))
		}

		_, ok := m[hash]
		if ok {
			// @TODO make more generic in future
			log.Fatal("Hash collision! Currently unimplemented\n")
			m[hash] = append(m[hash], fileName)
		} else {
			m[hash] = []string{fileName}
			hashAr = append(hashAr, hash)
		}
	}
	sort.Sort(hashAr)
	return hashAr, m
}

func generateFileBreakBody(arr myUintArray, m myMap) string {
	length := len(arr)
	return generateBreakHelper(arr, m, 0, length-1, 4)
}

func generateBreakHelper(arr myUintArray, m myMap, low, high, indent int) string {
	if high == low {
		return foundHash(arr[low], m[arr[low]], indent)
	}

	mid := (high + low) / 2
	if mid == low {
		// Can only happen when we have two elements left
		return ifThen(eq(arr[mid]),
			foundHash(arr[mid], m[arr[mid]], indent+4),
			foundHash(arr[high], m[arr[high]], indent+4),
			indent)
	}

	return ifThenElse(eq(arr[mid]),
		foundHash(arr[mid], m[arr[mid]], indent+4),
		lt(arr[mid]),
		generateBreakHelper(arr, m, low, mid-1, indent+4),
		generateBreakHelper(arr, m, mid+1, high, indent+4),
		indent)
}
